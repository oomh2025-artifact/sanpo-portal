<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åŠ´åƒè¡›ç”Ÿã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆ å£è¿°è©¦é¨“å¯¾ç­–</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    .animate-bounce { animation: bounce 1s infinite; }
    @keyframes bounce {
      0%, 100% { transform: translateY(-25%); animation-timing-function: cubic-bezier(0.8,0,1,1); }
      50% { transform: none; animation-timing-function: cubic-bezier(0,0,0.2,1); }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚­ãƒ¼
    const STORAGE_KEY = 'ohc-exam-review-items';

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å•é¡Œãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—æ™‚ç”¨ï¼‰
    const DEFAULT_THEMES = [
      {
        id: 1,
        name: "ã‚µãƒ³ãƒ—ãƒ«ï¼šç†±ä¸­ç—‡å¯¾ç­–",
        questions: [
          {
            level: "åŸºæœ¬",
            question: "ç†±ä¸­ç—‡ã‚’ç”Ÿã˜ã‚‹ãŠãã‚Œã®ã‚ã‚‹ä½œæ¥­ã®å®šç¾©ã«ã¤ã„ã¦èª¬æ˜ã—ã¦ãã ã•ã„ã€‚",
            modelAnswer: "ã€Œæš‘ç†±ãªå ´æ‰€ã€ã¨ã¯WBGT28åº¦ä»¥ä¸Šã¾ãŸã¯æ°—æ¸©31åº¦ä»¥ä¸Šã®å ´æ‰€ã‚’æŒ‡ã—ã¾ã™ã€‚",
            keyPoints: ["WBGT28åº¦ä»¥ä¸Šã¾ãŸã¯æ°—æ¸©31åº¦ä»¥ä¸Š"],
            followUpQuestions: ["WBGTã¨ã¯ä½•ã§ã™ã‹"]
          }
        ]
      }
    ];

    const DEFAULT_FOLLOW_UP_ANSWERS = {
      "WBGTã¨ã¯ä½•ã§ã™ã‹": "WBGTï¼ˆæ¹¿çƒé»’çƒæ¸©åº¦ï¼‰ã¯ç†±ä¸­ç—‡ãƒªã‚¹ã‚¯ã‚’è©•ä¾¡ã™ã‚‹æš‘ã•æŒ‡æ•°ã§ã™ã€‚"
    };

    // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ‘ãƒ¼ã‚µãƒ¼
    const parseQuestionsMarkdown = (markdown) => {
      const themes = [];
      let currentTheme = null;
      let currentQuestion = null;
      let currentSection = null;
      
      const lines = markdown.split('\n');
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        const themeMatch = line.match(/^##\s*(?:ãƒ†ãƒ¼ãƒ\d+[ï¼š:]\s*)?(.+?)$/);
        if (themeMatch && !line.includes('ã€äºˆæƒ³å•é¡Œ') && !line.includes('ç¬¬') && !line.includes('ç« ')) {
          if (currentTheme && currentTheme.questions.length > 0) {
            themes.push(currentTheme);
          }
          currentTheme = { id: themes.length + 1, name: themeMatch[1].trim(), questions: [] };
          currentQuestion = null;
          continue;
        }
        
        const questionMatch = line.match(/\*\*Q\d+[ï¼ˆ(](åŸºæœ¬|è©³ç´°|å¿œç”¨)å•é¡Œ[ï¼‰)][ï¼š:]\*\*/);
        if (questionMatch && currentTheme) {
          if (currentQuestion) currentTheme.questions.push(currentQuestion);
          currentQuestion = { level: questionMatch[1], question: '', modelAnswer: '', keyPoints: [], followUpQuestions: [] };
          currentSection = 'question';
          continue;
        }
        
        if (line.includes('ã€æ¨¡ç¯„è§£ç­”ã€‘')) { currentSection = 'modelAnswer'; continue; }
        if (line.includes('è©¦é¨“å®˜ãŒè¦‹ã¦ã„ã‚‹ãƒã‚¤ãƒ³ãƒˆ')) { currentSection = 'keyPoints'; continue; }
        if (line.includes('æƒ³å®šã•ã‚Œã‚‹è¿½åŠ è³ªå•')) { currentSection = 'followUp'; continue; }
        if (line.trim() === '---' || line.trim() === '') continue;
        if (line.includes('ã€äºˆæƒ³å•é¡Œ')) {
          if (currentQuestion) { currentTheme.questions.push(currentQuestion); currentQuestion = null; }
          continue;
        }
        
        if (currentQuestion && currentSection) {
          const cleanLine = line.trim();
          if (!cleanLine) continue;
          
          if (currentSection === 'question' && !cleanLine.startsWith('**') && !cleanLine.startsWith('#')) {
            currentQuestion.question += (currentQuestion.question ? ' ' : '') + cleanLine;
          } else if (currentSection === 'modelAnswer' && !cleanLine.startsWith('**') && !cleanLine.startsWith('#')) {
            currentQuestion.modelAnswer += (currentQuestion.modelAnswer ? '\n' : '') + cleanLine;
          } else if (currentSection === 'keyPoints' && (cleanLine.startsWith('-') || cleanLine.startsWith('ãƒ»'))) {
            currentQuestion.keyPoints.push(cleanLine.replace(/^[-ãƒ»]\s*/, ''));
          } else if (currentSection === 'followUp' && (cleanLine.startsWith('-') || cleanLine.startsWith('ãƒ»'))) {
            currentQuestion.followUpQuestions.push(cleanLine.replace(/^[-ãƒ»]\s*/, '').replace(/[ã€Œã€]/g, ''));
          }
        }
      }
      
      if (currentQuestion && currentTheme) currentTheme.questions.push(currentQuestion);
      if (currentTheme && currentTheme.questions.length > 0) themes.push(currentTheme);
      
      return themes;
    };

    const parseFollowUpMarkdown = (markdown) => {
      const followUps = {};
      let currentQuestion = null;
      let currentAnswer = '';
      
      const lines = markdown.split('\n');
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        const questionMatch = line.match(/^###\s*Q[ï¼š:]\s*(.+)$/);
        if (questionMatch) {
          if (currentQuestion && currentAnswer) followUps[currentQuestion] = currentAnswer.trim();
          currentQuestion = questionMatch[1].trim();
          currentAnswer = '';
          continue;
        }
        
        const answerMatch = line.match(/^\*\*A[ï¼š:]\*\*\s*(.*)$/);
        if (answerMatch) { currentAnswer = answerMatch[1]; continue; }
        if (line.trim() === '---' || line.startsWith('## ') || line.trim() === '') continue;
        if (currentQuestion && !line.startsWith('#') && !line.startsWith('**')) {
          currentAnswer += ' ' + line.trim();
        }
      }
      
      if (currentQuestion && currentAnswer) followUps[currentQuestion] = currentAnswer.trim();
      return followUps;
    };

    function App() {
      const [appMode, setAppMode] = useState('loading');
      const [themes, setThemes] = useState(DEFAULT_THEMES);
      const [followUpAnswers, setFollowUpAnswers] = useState(DEFAULT_FOLLOW_UP_ANSWERS);
      const [reviewItems, setReviewItems] = useState([]);
      const [loadError, setLoadError] = useState(null);
      
      const [gameState, setGameState] = useState('start');
      const [messages, setMessages] = useState([]);
      const [inputValue, setInputValue] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const [currentThemeIndex, setCurrentThemeIndex] = useState(0);
      const [currentQuestionLevel, setCurrentQuestionLevel] = useState(0);
      const [completedThemes, setCompletedThemes] = useState([]);
      const [scores, setScores] = useState([]);
      const [totalScore, setTotalScore] = useState(0);
      const [followUpQuestion, setFollowUpQuestion] = useState(null);
      const [waitingForFollowUp, setWaitingForFollowUp] = useState(false);
      const [usedThemes, setUsedThemes] = useState([]);
      const [takeHomeCount, setTakeHomeCount] = useState(0);
      const [takeHomeThemes, setTakeHomeThemes] = useState([]);
      const [currentReviewIndex, setCurrentReviewIndex] = useState(0);
      const MAX_TAKE_HOME = 2;
      
      const messagesEndRef = useRef(null);

      // åˆæœŸåŒ–ï¼šãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
      useEffect(() => {
        const loadData = async () => {
          try {
            // å¾©ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’localStorageã‹ã‚‰èª­ã¿è¾¼ã¿
            const savedReview = localStorage.getItem(STORAGE_KEY);
            if (savedReview) {
              setReviewItems(JSON.parse(savedReview));
            }
            
            // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            const [questionsRes, followUpRes] = await Promise.all([
              fetch('./data/questions.md').catch(() => null),
              fetch('./data/followup.md').catch(() => null)
            ]);
            
            if (questionsRes && questionsRes.ok) {
              const questionsText = await questionsRes.text();
              const parsed = parseQuestionsMarkdown(questionsText);
              if (parsed.length > 0) {
                setThemes(parsed);
              }
            }
            
            if (followUpRes && followUpRes.ok) {
              const followUpText = await followUpRes.text();
              const parsed = parseFollowUpMarkdown(followUpText);
              if (Object.keys(parsed).length > 0) {
                setFollowUpAnswers(parsed);
              }
            }
            
            setAppMode('menu');
          } catch (err) {
            console.error('Load error:', err);
            setLoadError(err.message);
            setAppMode('menu');
          }
        };
        
        loadData();
      }, []);

      // å¾©ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
      useEffect(() => {
        if (appMode !== 'loading') {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(reviewItems));
        }
      }, [reviewItems, appMode]);

      const scrollToBottom = () => messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
      useEffect(() => { scrollToBottom(); }, [messages]);

      const addMessage = (role, content) => setMessages(prev => [...prev, { role, content }]);

      // æ¡ç‚¹API
      const gradeAnswer = async (question, modelAnswer, keyPoints, userAnswer) => {
        try {
          const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              model: "claude-sonnet-4-20250514",
              max_tokens: 1000,
              system: `ã‚ãªãŸã¯åŠ´åƒè¡›ç”Ÿã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆå£è¿°è©¦é¨“ã®æ¡ç‚¹è€…ã§ã™ã€‚10ç‚¹æº€ç‚¹ã§æ¡ç‚¹ã—ã¦ãã ã•ã„ã€‚
ã€æ¡ç‚¹åŸºæº–ã€‘10ç‚¹:å®Œç’§ 8-9ç‚¹:å„ªç§€ 6-7ç‚¹:åˆæ ¼ 4-5ç‚¹:ä¸€éƒ¨æ­£è§£ 2-3ç‚¹:æ–¹å‘æ€§ã®ã¿ 0-1ç‚¹:çš„å¤–ã‚Œ
å¿…ãšä»¥ä¸‹ã®å½¢å¼ã§å›ç­”ï¼š
ç‚¹æ•°: [0-10]
è¬›è©•: [100å­—ä»¥å†…]`,
              messages: [{
                role: "user",
                content: `ã€å•é¡Œã€‘${question}\nã€æ¨¡ç¯„è§£ç­”ã€‘${modelAnswer}\nã€ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆã€‘${keyPoints.join(', ')}\nã€å—é¨“è€…ã®å›ç­”ã€‘${userAnswer}\n\næ¡ç‚¹ã—ã¦ãã ã•ã„ã€‚`
              }]
            })
          });
          const data = await response.json();
          const text = data.content[0].text;
          const scoreMatch = text.match(/ç‚¹æ•°[:ï¼š]\s*(\d+)/);
          const feedbackMatch = text.match(/è¬›è©•[:ï¼š]\s*(.+)/s);
          return {
            score: scoreMatch ? parseInt(scoreMatch[1]) : 5,
            feedback: feedbackMatch ? feedbackMatch[1].trim() : text
          };
        } catch (error) {
          console.error('Grading error:', error);
          return { score: 5, feedback: 'æ¡ç‚¹ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚' };
        }
      };

      const addToReview = (item) => {
        const newItem = { ...item, id: Date.now(), addedAt: new Date().toISOString() };
        setReviewItems(prev => [...prev, newItem]);
      };

      const removeFromReview = (id) => {
        setReviewItems(prev => prev.filter(item => item.id !== id));
      };

      const selectNextTheme = () => {
        const availableThemes = themes.filter((_, idx) => !usedThemes.includes(idx));
        if (availableThemes.length === 0) return null;
        const randomIndex = Math.floor(Math.random() * availableThemes.length);
        const theme = availableThemes[randomIndex];
        const originalIndex = themes.findIndex(t => t.id === theme.id);
        setUsedThemes(prev => [...prev, originalIndex]);
        setCurrentThemeIndex(originalIndex);
        setCurrentQuestionLevel(0);
        return theme;
      };

      const getCurrentQuestion = () => {
        const theme = themes[currentThemeIndex];
        if (!theme) return null;
        return theme.questions[currentQuestionLevel];
      };

      const startExam = () => {
        setAppMode('exam');
        setGameState('start');
        setMessages([]);
        setCurrentThemeIndex(0);
        setCurrentQuestionLevel(0);
        setCompletedThemes([]);
        setScores([]);
        setTotalScore(0);
        setFollowUpQuestion(null);
        setWaitingForFollowUp(false);
        setUsedThemes([]);
        setTakeHomeCount(0);
        setTakeHomeThemes([]);
        
        const maxThemes = Math.min(5, themes.length);
        setTimeout(() => {
          setMessages([{
            role: 'examiner',
            content: `åŠ´åƒè¡›ç”Ÿã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆï¼ˆä¿å¥è¡›ç”Ÿï¼‰å£è¿°è©¦é¨“å¯¾ç­–ã¸ã‚ˆã†ã“ãã€‚

ğŸ“‹ **è©¦é¨“ãƒ«ãƒ¼ãƒ«**
â€¢ ${maxThemes}ã¤ã®ãƒ†ãƒ¼ãƒã«ã¤ã„ã¦å‡ºé¡Œã—ã¾ã™
â€¢ å„å•é¡Œã¯10ç‚¹æº€ç‚¹ã§æ¡ç‚¹
â€¢ 6ç‚¹ä»¥ä¸Šã§æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸
â€¢ 5ç‚¹ä»¥ä¸‹ã§è£œè¶³è³ªå•

ğŸ“¦ **æŒã¡å¸°ã‚Šãƒ«ãƒ¼ãƒ«**
â€¢ ã€ŒæŒã¡å¸°ã‚Šã€ã¯2å›ã¾ã§
â€¢ 3å›ç›®ã§ä¸åˆæ ¼

ğŸ“š **å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€**
â€¢ 5ç‚¹ä»¥ä¸‹ã¯è‡ªå‹•ã§å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€ã¸

âœ… **åˆæ ¼åŸºæº–**
â€¢ å›ç­”ã—ãŸãƒ†ãƒ¼ãƒã®60%ä»¥ä¸Š

ã€Œé–‹å§‹ã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`
          }]);
        }, 100);
      };

      const startReviewExam = () => {
        if (reviewItems.length === 0) return;
        setAppMode('reviewExam');
        setCurrentReviewIndex(0);
        setMessages([]);
        setGameState('question');
        
        const item = reviewItems[0];
        setTimeout(() => {
          setMessages([{
            role: 'examiner',
            content: `ğŸ“š **å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰** (${reviewItems.length}å•)

**ã€${item.themeName} - ${item.level}ã€‘**
${item.question}

ğŸ’¡ å‰å›ï¼š${item.score}ç‚¹`
          }]);
        }, 100);
      };

      const handleTakeHome = () => {
        if (takeHomeCount >= MAX_TAKE_HOME) {
          setGameState('result');
          addMessage('user', 'æŒã¡å¸°ã‚‰ã›ã¦ã„ãŸã ãã¾ã™ã€‚');
          setTimeout(() => {
            const question = getCurrentQuestion();
            addMessage('examiner', `ğŸ“¦ **æŒã¡å¸°ã‚Šï¼ˆ3å›ç›®ï¼‰- ä¸åˆæ ¼**

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${question?.modelAnswer || ''}

ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸`);
          }, 500);
          return;
        }

        const question = getCurrentQuestion();
        setTakeHomeCount(prev => prev + 1);
        setTakeHomeThemes(prev => [...prev, currentThemeIndex]);
        addMessage('user', 'æŒã¡å¸°ã‚‰ã›ã¦ã„ãŸã ãã¾ã™ã€‚');
        
        setTimeout(() => {
          addMessage('examiner', `ğŸ“¦ **æŒã¡å¸°ã‚Šï¼ˆ${takeHomeCount + 1}/${MAX_TAKE_HOME}å›ï¼‰**

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${question?.modelAnswer}`);
          setTimeout(() => handleThemeComplete(true), 1500);
        }, 500);
      };

      const handleThemeComplete = (isTakeHome = false) => {
        if (!isTakeHome) setCompletedThemes(prev => [...prev, currentThemeIndex]);
        const maxThemes = Math.min(5, themes.length);
        
        if (usedThemes.length >= maxThemes) {
          setGameState('result');
          const validScores = scores.filter(s => {
            const themeIdx = themes.findIndex(t => t.name === s.theme);
            return !takeHomeThemes.includes(themeIdx);
          });
          const answeredThemeCount = maxThemes - takeHomeThemes.length - (isTakeHome ? 1 : 0);
          const maxPossibleScore = answeredThemeCount * 30;
          const actualScore = validScores.reduce((acc, s) => acc + s.score, 0);
          const percentage = maxPossibleScore > 0 ? Math.round((actualScore / maxPossibleScore) * 100) : 0;
          const passed = percentage >= 60;
          
          addMessage('examiner', `ğŸ¯ **è©¦é¨“çµ‚äº†**

ğŸ“Š **çµæœ**
å›ç­”ï¼š${answeredThemeCount}ãƒ†ãƒ¼ãƒ / æŒã¡å¸°ã‚Šï¼š${takeHomeThemes.length + (isTakeHome ? 1 : 0)}
å¾—ç‚¹ï¼š${actualScore}/${maxPossibleScore}ç‚¹ï¼ˆ${percentage}%ï¼‰

**åˆ¤å®šï¼š${passed ? 'ğŸ‰ åˆæ ¼' : 'ğŸ“š ä¸åˆæ ¼'}**

ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸`);
        } else {
          setGameState('question');
          const theme = selectNextTheme();
          if (theme) {
            const q = theme.questions[0];
            addMessage('examiner', `ğŸ“š **ãƒ†ãƒ¼ãƒ ${usedThemes.length}/${maxThemes}ï¼š${theme.name}**

ã€åŸºæœ¬å•é¡Œã€‘${q.question}`);
          }
        }
      };

      const handleSend = async () => {
        if (!inputValue.trim() || isLoading) return;
        const userInput = inputValue.trim();
        setInputValue('');
        addMessage('user', userInput);
        setIsLoading(true);

        try {
          if (userInput.includes('ãƒ¡ãƒ‹ãƒ¥ãƒ¼')) {
            setAppMode('menu');
            setIsLoading(false);
            return;
          }

          // å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰
          if (appMode === 'reviewExam') {
            if (gameState === 'confirmDelete') {
              if (userInput === 'å‰Šé™¤') {
                removeFromReview(reviewItems[currentReviewIndex].id);
                addMessage('examiner', 'âœ… å‰Šé™¤ã—ã¾ã—ãŸã€‚');
              }
              const newItems = userInput === 'å‰Šé™¤' ? reviewItems.filter((_, i) => i !== currentReviewIndex) : reviewItems;
              if (newItems.length === 0 || currentReviewIndex >= newItems.length) {
                addMessage('examiner', 'ğŸ“š å¾©ç¿’å®Œäº†ï¼ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸');
                setGameState('result');
              } else {
                setGameState('question');
                const next = newItems[currentReviewIndex];
                addMessage('examiner', `**ã€${next.themeName} - ${next.level}ã€‘** (${currentReviewIndex + 1}/${newItems.length})
${next.question}
ğŸ’¡ å‰å›ï¼š${next.score}ç‚¹`);
              }
              setIsLoading(false);
              return;
            }

            const item = reviewItems[currentReviewIndex];
            const result = await gradeAnswer(item.question, item.modelAnswer, item.keyPoints || [], userInput);
            const improved = result.score > item.score;
            
            addMessage('examiner', `**${result.score}ç‚¹** ${improved ? 'ğŸ“ˆ' : ''}
${result.feedback}

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${item.modelAnswer}`);

            setTimeout(() => {
              if (result.score >= 6) {
                addMessage('examiner', 'âœ¨ åˆæ ¼ï¼ã€Œå‰Šé™¤ã€ã§å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å‰Šé™¤ã€ä»–ã®å…¥åŠ›ã§æ¬¡ã¸');
                setGameState('confirmDelete');
              } else {
                if (currentReviewIndex < reviewItems.length - 1) {
                  setCurrentReviewIndex(prev => prev + 1);
                  const next = reviewItems[currentReviewIndex + 1];
                  addMessage('examiner', `**ã€${next.themeName} - ${next.level}ã€‘** (${currentReviewIndex + 2}/${reviewItems.length})
${next.question}
ğŸ’¡ å‰å›ï¼š${next.score}ç‚¹`);
                } else {
                  addMessage('examiner', 'ğŸ“š å¾©ç¿’å®Œäº†ï¼ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸');
                  setGameState('result');
                }
              }
            }, 1500);
            setIsLoading(false);
            return;
          }

          // é€šå¸¸è©¦é¨“
          if (gameState === 'start') {
            if (userInput.includes('é–‹å§‹')) {
              const theme = selectNextTheme();
              if (theme) {
                setGameState('question');
                const q = theme.questions[0];
                addMessage('examiner', `ğŸ“š **ãƒ†ãƒ¼ãƒ ${usedThemes.length}/${Math.min(5, themes.length)}ï¼š${theme.name}**

ã€åŸºæœ¬å•é¡Œã€‘${q.question}`);
              }
            }
          } else if (gameState === 'question') {
            const question = getCurrentQuestion();
            if (!question) return;
            
            const result = await gradeAnswer(question.question, question.modelAnswer, question.keyPoints, userInput);
            const newScore = { theme: themes[currentThemeIndex].name, level: question.level, score: result.score, addedToReview: false };
            
            if (result.score <= 5) {
              addToReview({
                themeName: themes[currentThemeIndex].name,
                level: question.level,
                question: question.question,
                modelAnswer: question.modelAnswer,
                keyPoints: question.keyPoints,
                userAnswer: userInput,
                score: result.score,
                feedback: result.feedback
              });
              newScore.addedToReview = true;
            }
            
            setScores(prev => [...prev, newScore]);
            setTotalScore(prev => prev + result.score);
            
            const emoji = result.score >= 8 ? 'ğŸŒŸ' : result.score >= 6 ? 'âœ…' : 'âš ï¸';
            addMessage('examiner', `${emoji} **${result.score}ç‚¹**
${result.feedback}${result.score <= 5 ? '\nğŸ“š å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€ã«è¿½åŠ ' : ''}

ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${question.modelAnswer}`);

            setTimeout(() => {
              if (result.score >= 6) {
                if (currentQuestionLevel < 2 && themes[currentThemeIndex].questions.length > currentQuestionLevel + 1) {
                  setCurrentQuestionLevel(prev => prev + 1);
                  const nextQ = themes[currentThemeIndex].questions[currentQuestionLevel + 1];
                  addMessage('examiner', `âœ¨ æ¬¡ã¸ï¼ã€${nextQ.level}å•é¡Œã€‘${nextQ.question}`);
                } else {
                  handleThemeComplete();
                }
              } else {
                const followUp = question.followUpQuestions?.[0];
                if (followUp) {
                  setFollowUpQuestion(followUp);
                  setGameState('followUp');
                  addMessage('examiner', `ğŸ’¡ è£œè¶³è³ªå•ï¼š**${followUp}**`);
                } else {
                  handleThemeComplete();
                }
              }
            }, 1500);
          } else if (gameState === 'followUp') {
            const expectedAnswer = followUpAnswers[followUpQuestion] || '';
            const result = await gradeAnswer(followUpQuestion, expectedAnswer || 'é©åˆ‡ãªèª¬æ˜', [], userInput);
            
            if (result.score <= 5) {
              addToReview({
                themeName: themes[currentThemeIndex].name,
                level: 'è¿½åŠ è³ªå•',
                question: followUpQuestion,
                modelAnswer: expectedAnswer || 'ï¼ˆæœªç™»éŒ²ï¼‰',
                keyPoints: [],
                userAnswer: userInput,
                score: result.score,
                feedback: result.feedback,
                isFollowUp: true
              });
            }
            
            addMessage('examiner', `**${result.score}ç‚¹**
${result.feedback}
ğŸ“– æ¨¡ç¯„è§£ç­”ï¼š${expectedAnswer || 'ï¼ˆæœªç™»éŒ²ï¼‰'}`);

            setFollowUpQuestion(null);
            setTimeout(() => {
              if (result.score >= 6) {
                setGameState('question');
                if (currentQuestionLevel < 2 && themes[currentThemeIndex].questions.length > currentQuestionLevel + 1) {
                  setCurrentQuestionLevel(prev => prev + 1);
                  const nextQ = themes[currentThemeIndex].questions[currentQuestionLevel + 1];
                  addMessage('examiner', `âœ¨ æ¬¡ã¸ï¼ã€${nextQ.level}å•é¡Œã€‘${nextQ.question}`);
                } else {
                  handleThemeComplete();
                }
              } else {
                handleThemeComplete();
              }
            }, 1500);
          }
        } catch (error) {
          console.error('Error:', error);
          addMessage('examiner', 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
        } finally {
          setIsLoading(false);
        }
      };

      // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
      if (appMode === 'loading') {
        return (
          <div className="min-h-screen bg-blue-50 flex items-center justify-center">
            <div className="text-center">
              <div className="text-4xl mb-4">ğŸ“š</div>
              <p className="text-blue-700">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
            </div>
          </div>
        );
      }

      // ãƒ¡ãƒ‹ãƒ¥ãƒ¼
      if (appMode === 'menu') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4">
            <div className="max-w-2xl mx-auto pt-8">
              <div className="text-center mb-8">
                <h1 className="text-2xl font-bold text-blue-900 mb-2">åŠ´åƒè¡›ç”Ÿã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆ</h1>
                <p className="text-lg text-blue-700">å£è¿°è©¦é¨“å¯¾ç­–ã‚·ã‚¹ãƒ†ãƒ </p>
              </div>
              
              {loadError && (
                <div className="bg-yellow-50 border border-yellow-200 rounded-xl p-4 mb-4 text-sm text-yellow-800">
                  âš ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«ä¸€éƒ¨å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
                </div>
              )}
              
              <div className="space-y-4">
                <button onClick={startExam} className="w-full bg-blue-600 hover:bg-blue-700 text-white rounded-2xl p-6 text-left shadow-lg">
                  <div className="flex items-center gap-4">
                    <span className="text-3xl">ğŸ“</span>
                    <div>
                      <h2 className="text-xl font-bold">è©¦é¨“ã‚’é–‹å§‹</h2>
                      <p className="text-blue-200 text-sm">ãƒ©ãƒ³ãƒ€ãƒ ã«å‡ºé¡Œ</p>
                    </div>
                  </div>
                </button>
                
                <button onClick={() => setAppMode('review')} className="w-full bg-amber-500 hover:bg-amber-600 text-white rounded-2xl p-6 text-left shadow-lg relative">
                  <div className="flex items-center gap-4">
                    <span className="text-3xl">ğŸ“š</span>
                    <div>
                      <h2 className="text-xl font-bold">å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€</h2>
                      <p className="text-amber-100 text-sm">5ç‚¹ä»¥ä¸‹ã®å•é¡Œã‚’å¾©ç¿’</p>
                    </div>
                  </div>
                  {reviewItems.length > 0 && (
                    <span className="absolute top-4 right-4 bg-red-500 text-white text-sm font-bold px-3 py-1 rounded-full">
                      {reviewItems.length}
                    </span>
                  )}
                </button>
              </div>
              
              <div className="mt-6 grid grid-cols-3 gap-3">
                <div className="bg-white rounded-xl p-3 shadow text-center">
                  <div className="text-2xl font-bold text-blue-600">{themes.length}</div>
                  <div className="text-gray-500 text-xs">ãƒ†ãƒ¼ãƒ</div>
                </div>
                <div className="bg-white rounded-xl p-3 shadow text-center">
                  <div className="text-2xl font-bold text-green-600">{themes.reduce((a, t) => a + t.questions.length, 0)}</div>
                  <div className="text-gray-500 text-xs">å•é¡Œ</div>
                </div>
                <div className="bg-white rounded-xl p-3 shadow text-center">
                  <div className="text-2xl font-bold text-purple-600">{Object.keys(followUpAnswers).length}</div>
                  <div className="text-gray-500 text-xs">è¿½åŠ è³ªå•</div>
                </div>
              </div>
              
              <div className="mt-4 bg-white rounded-xl p-4 shadow">
                <h3 className="font-bold text-gray-800 mb-2 text-sm">ğŸ“‹ ãƒ†ãƒ¼ãƒä¸€è¦§</h3>
                <div className="flex flex-wrap gap-2">
                  {themes.map(t => (
                    <span key={t.id} className="bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs">
                      {t.name}
                    </span>
                  ))}
                </div>
              </div>
            </div>
          </div>
        );
      }

      // å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€
      if (appMode === 'review') {
        return (
          <div className="min-h-screen bg-slate-50">
            <div className="bg-amber-500 text-white p-4">
              <div className="max-w-4xl mx-auto flex justify-between items-center">
                <h1 className="text-xl font-bold">ğŸ“š å¾©ç¿’ãƒ•ã‚©ãƒ«ãƒ€</h1>
                <button onClick={() => setAppMode('menu')} className="bg-amber-600 px-4 py-2 rounded-lg text-sm">
                  æˆ»ã‚‹
                </button>
              </div>
            </div>
            <div className="max-w-4xl mx-auto p-4">
              {reviewItems.length === 0 ? (
                <div className="bg-white rounded-xl p-8 shadow text-center">
                  <span className="text-5xl mb-4 block">ğŸ‰</span>
                  <p className="text-gray-600">å¾©ç¿’ã™ã‚‹å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“</p>
                </div>
              ) : (
                <>
                  <div className="flex justify-between mb-4">
                    <p className="text-gray-600">{reviewItems.length}å•</p>
                    <button onClick={startReviewExam} className="bg-amber-500 text-white px-4 py-2 rounded-lg">
                      ğŸ¯ å¾©ç¿’é–‹å§‹
                    </button>
                  </div>
                  <div className="space-y-3">
                    {reviewItems.map(item => (
                      <div key={item.id} className="bg-white rounded-xl p-4 shadow">
                        <div className="flex justify-between">
                          <div>
                            <span className="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded mr-2">{item.level}</span>
                            <span className="font-medium">{item.themeName}</span>
                          </div>
                          <div className="flex items-center gap-2">
                            <span className="text-red-500 font-bold">{item.score}ç‚¹</span>
                            <button onClick={() => removeFromReview(item.id)} className="text-gray-400 hover:text-red-500">âœ•</button>
                          </div>
                        </div>
                        <p className="text-gray-700 text-sm mt-2">{item.question.substring(0, 80)}...</p>
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
          </div>
        );
      }

      // è©¦é¨“ç”»é¢
      const maxThemes = Math.min(5, themes.length);
      const canTakeHome = appMode === 'exam' && (gameState === 'question' || gameState === 'followUp');
      const isReviewMode = appMode === 'reviewExam';
      
      return (
        <div className="flex flex-col h-screen bg-slate-50">
          <div className={`${isReviewMode ? 'bg-amber-500' : 'bg-blue-700'} text-white p-4`}>
            <div className="max-w-4xl mx-auto flex justify-between items-center">
              <h1 className="font-bold">{isReviewMode ? 'ğŸ“š å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰' : 'å£è¿°è©¦é¨“å¯¾ç­–'}</h1>
              {!isReviewMode && (
                <div className="text-sm">
                  ãƒ†ãƒ¼ãƒ {usedThemes.length}/{maxThemes} | æŒã¡å¸°ã‚Šæ®‹ã‚Š {MAX_TAKE_HOME - takeHomeCount}
                </div>
              )}
            </div>
          </div>

          <div className="flex-1 overflow-y-auto p-4">
            <div className="max-w-4xl mx-auto space-y-4">
              {messages.map((msg, idx) => (
                <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                  <div className={`max-w-3xl rounded-2xl px-4 py-3 ${
                    msg.role === 'user' ? 'bg-blue-600 text-white' : 'bg-white border shadow-sm'
                  }`}>
                    <div className="whitespace-pre-wrap text-sm">
                      {msg.content.split(/(\*\*[^*]+\*\*)/).map((part, i) => 
                        part.startsWith('**') && part.endsWith('**') 
                          ? <strong key={i}>{part.slice(2, -2)}</strong> 
                          : part
                      )}
                    </div>
                  </div>
                </div>
              ))}
              {isLoading && (
                <div className="flex justify-start">
                  <div className="bg-white border rounded-2xl px-4 py-3 shadow-sm">
                    <span className="text-gray-500 text-sm">æ¡ç‚¹ä¸­...</span>
                  </div>
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>
          </div>

          <div className="bg-white border-t p-4">
            <div className="max-w-4xl mx-auto flex gap-2">
              {canTakeHome && (
                <button onClick={handleTakeHome} disabled={isLoading}
                  className="px-4 py-3 rounded-xl font-semibold bg-amber-100 text-amber-700 border-2 border-amber-300">
                  ğŸ“¦ æŒã¡å¸°ã‚Š
                </button>
              )}
              <textarea
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } }}
                placeholder="å›ç­”ã‚’å…¥åŠ›..."
                className="flex-1 border rounded-xl px-4 py-3 resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                rows={2}
                disabled={isLoading}
              />
              <button onClick={handleSend} disabled={isLoading || !inputValue.trim()}
                className="bg-blue-600 text-white px-6 py-3 rounded-xl font-semibold hover:bg-blue-700 disabled:bg-gray-300">
                é€ä¿¡
              </button>
            </div>
            <p className="text-xs text-gray-500 mt-2 text-center">ã€Œãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€ã§æˆ»ã‚‹</p>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
